{
	"$schema": "http://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",
	"contentVersion": "1.0.0.0",
	"parameters": {
		"factoryName": {
			"type": "string",
			"metadata": "Data Factory name",
			"defaultValue": "adf-giriprasad-dev-datafactory"
		}
	},
	"variables": {
		"factoryId": "[concat('Microsoft.DataFactory/factories/', parameters('factoryName'))]"
	},
	"resources": [
		{
			"name": "[concat(parameters('factoryName'), '/JoinAndAggregateData')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "TripDataCSV",
								"type": "DatasetReference"
							},
							"name": "TripDataCsv"
						},
						{
							"dataset": {
								"referenceName": "TripFaresSQLtable",
								"type": "DatasetReference"
							},
							"name": "TripFaresSQLdb"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "JoinAndAggregateSink",
								"type": "DatasetReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [
						{
							"name": "InnerJoinWithTripFares"
						},
						{
							"name": "aggregatebyPaymentType"
						}
					],
					"scriptLines": [
						"source(output(",
						"          medallion as string,",
						"          hack_license as string,",
						"          vendor_id as string,",
						"          rate_code as string,",
						"          store_and_fwd_flag as string,",
						"          pickup_datetime as string,",
						"          dropoff_datetime as string,",
						"          passenger_count as string,",
						"          trip_time_in_secs as string,",
						"          trip_distance as string,",
						"          pickup_longitude as string,",
						"          pickup_latitude as string,",
						"          dropoff_longitude as string,",
						"          dropoff_latitude as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false) ~> TripDataCsv",
						"source(output(",
						"          medallion as string,",
						"          hack_license as string,",
						"          vendor_id as string,",
						"          pickup_datetime as string,",
						"          payment_type as string,",
						"          fare_amount as string,",
						"          surcharge as string,",
						"          mta_tax as string,",
						"          tip_amount as string,",
						"          tolls_amount as string,",
						"          total_amount as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> TripFaresSQLdb",
						"TripDataCsv, TripFaresSQLdb join(TripDataCsv@medallion == TripFaresSQLdb@medallion",
						"     && TripDataCsv@hack_license == TripFaresSQLdb@hack_license",
						"     && TripDataCsv@pickup_datetime == TripFaresSQLdb@pickup_datetime",
						"     && TripDataCsv@vendor_id == TripFaresSQLdb@vendor_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> InnerJoinWithTripFares",
						"InnerJoinWithTripFares aggregate(groupBy(payment_type),",
						"     average_fare = avg(toInteger(total_amount)),",
						"          total_trip_distance = sum(toInteger(trip_distance))) ~> aggregatebyPaymentType",
						"aggregatebyPaymentType sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     partitionBy('hash', 1)) ~> sink1"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/moviesDBconditionalsplit')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "moviesdbip",
								"type": "DatasetReference"
							},
							"name": "moviesDBcsv"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "moviesdbout",
								"type": "DatasetReference"
							},
							"name": "before1960"
						},
						{
							"dataset": {
								"referenceName": "moviesdbout",
								"type": "DatasetReference"
							},
							"name": "after1980"
						},
						{
							"dataset": {
								"referenceName": "moviesdbout",
								"type": "DatasetReference"
							},
							"name": "allother"
						}
					],
					"transformations": [
						{
							"name": "splitonyear"
						}
					],
					"scriptLines": [
						"source(output(",
						"          movie as string,",
						"          title as string,",
						"          genres as string,",
						"          year as integer,",
						"          Rating as string,",
						"          {Rotton Tomato} as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false) ~> moviesDBcsv",
						"moviesDBcsv split(year<1960,",
						"     year>1980,",
						"     disjoint: false) ~> splitonyear@(moviesBefore1960, moviesafter1980, allothermovies)",
						"splitonyear@moviesBefore1960 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     partitionBy('hash', 1)) ~> before1960",
						"splitonyear@moviesafter1980 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     partitionBy('hash', 1)) ~> after1980",
						"splitonyear@allothermovies sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     partitionBy('hash', 1)) ~> allother"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/moviesDBderivedcoln')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "moviesdbip",
								"type": "DatasetReference"
							},
							"name": "moviesdbcsv"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "moviesdbout",
								"type": "DatasetReference"
							},
							"name": "derivedcolnsink"
						}
					],
					"transformations": [
						{
							"name": "primarygenres"
						},
						{
							"name": "select1"
						}
					],
					"scriptLines": [
						"source(output(",
						"          movie as string,",
						"          title as string,",
						"          genres as string,",
						"          year as string,",
						"          Rating as string,",
						"          {Rotton Tomato} as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false) ~> moviesdbcsv",
						"moviesdbcsv derive({primary genre} = iif(locate('|',genres)>1,left(genres,locate('|',genres)-1),genres)) ~> primarygenres",
						"primarygenres select(mapColumn(",
						"          movie,",
						"          title,",
						"          genres,",
						"          year,",
						"          Rating,",
						"          {Rotten Tomato} = {Rotton Tomato},",
						"          {primary genre}",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"select1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     partitionFileNames:['moviesdbderivedcoln'],",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     partitionBy('hash', 1)) ~> derivedcolnsink"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/moviesDBexists')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "moviesdbip",
								"type": "DatasetReference"
							},
							"name": "moviesdbcsv"
						},
						{
							"dataset": {
								"referenceName": "moviesDBcopyinput",
								"type": "DatasetReference"
							},
							"name": "moviesdbcopycsv"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "moviesdbout",
								"type": "DatasetReference"
							},
							"name": "moviesDBexistes"
						}
					],
					"transformations": [
						{
							"name": "exists1"
						}
					],
					"scriptLines": [
						"source(output(",
						"          movie as string,",
						"          title as string,",
						"          genres as string,",
						"          year as string,",
						"          Rating as string,",
						"          {Rotton Tomato} as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false) ~> moviesdbcsv",
						"source(output(",
						"          movie as string,",
						"          title as string,",
						"          genres as string,",
						"          year as string,",
						"          Rating as string,",
						"          {Rotton Tomato} as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false) ~> moviesdbcopycsv",
						"moviesdbcsv, moviesdbcopycsv exists(concat(moviesdbcsv@movie, moviesdbcsv@title) == concat(moviesdbcopycsv@movie, moviesdbcopycsv@title),",
						"     negate:true,",
						"     broadcast: 'auto')~> exists1",
						"exists1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     partitionFileNames:['moviesDBexistes'],",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     partitionBy('hash', 1)) ~> moviesDBexistes"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/moviesDBlookup')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "moviesdbip",
								"type": "DatasetReference"
							},
							"name": "moviesdbcsv"
						},
						{
							"dataset": {
								"referenceName": "moviesDBcopyinput",
								"type": "DatasetReference"
							},
							"name": "moviesdbcopycsv"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "moviesdbout",
								"type": "DatasetReference"
							},
							"name": "moviesDBexistes"
						}
					],
					"transformations": [
						{
							"name": "lookup1"
						},
						{
							"name": "select1"
						}
					],
					"scriptLines": [
						"source(output(",
						"          movie as string,",
						"          title as string,",
						"          genres as string,",
						"          year as string,",
						"          Rating as string,",
						"          {Rotton Tomato} as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false) ~> moviesdbcsv",
						"source(output(",
						"          movie as string,",
						"          title as string,",
						"          genres as string,",
						"          year as string,",
						"          Rating as string,",
						"          {Rotton Tomato} as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false) ~> moviesdbcopycsv",
						"moviesdbcsv, moviesdbcopycsv lookup(moviesdbcsv@movie == moviesdbcopycsv@movie,",
						"     multiple: false,",
						"     pickup: 'first',",
						"     desc(moviesdbcopycsv@Rating, true),",
						"     broadcast: 'auto')~> lookup1",
						"lookup1 select(mapColumn(",
						"          movie = moviesdbcsv@movie,",
						"          title = moviesdbcsv@title,",
						"          genres = moviesdbcsv@genres,",
						"          year = moviesdbcsv@year,",
						"          Rating = moviesdbcsv@Rating,",
						"          {Rotton Tomato} = moviesdbcsv@{Rotton Tomato},",
						"          movie1 = moviesdbcopycsv@movie,",
						"          title1 = moviesdbcopycsv@title,",
						"          genres1 = moviesdbcopycsv@genres,",
						"          year1 = moviesdbcopycsv@year,",
						"          Rating1 = moviesdbcopycsv@Rating,",
						"          {Rotton Tomato1} = moviesdbcopycsv@{Rotton Tomato}",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"select1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     partitionFileNames:['moviesDBlookup'],",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     partitionBy('hash', 1)) ~> moviesDBexistes"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/moviesdb')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "moviesdbip",
								"type": "DatasetReference"
							},
							"name": "moviesdb"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "moviesdbout",
								"type": "DatasetReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [
						{
							"name": "filteryears"
						},
						{
							"name": "AggregateComedyRating"
						}
					],
					"scriptLines": [
						"source(output(",
						"          movie as string,",
						"          title as string,",
						"          genres as string,",
						"          year as string,",
						"          Rating as string,",
						"          {Rotton Tomato} as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false) ~> moviesdb",
						"moviesdb filter(toInteger(year) >= 1910 && toInteger(year) <= 2000 && rlike(genres, 'Comedy')) ~> filteryears",
						"filteryears aggregate(groupBy(year),",
						"     AverageComedyRating = avg(toInteger(Rating))) ~> AggregateComedyRating",
						"AggregateComedyRating sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     partitionBy('hash', 1)) ~> sink1"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/JoinAndAggregate_DataFlow')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "JoinAndAggregate_DataFlow",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "JoinAndAggregateData",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"TripDataCsv": {},
									"TripFaresSQLdb": {},
									"sink1": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"annotations": [],
				"lastPublishTime": "2022-12-27T09:08:29Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/JoinAndAggregateData')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/moviesDBconditionalSplitDF')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "moviesdb conditional split",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "moviesDBconditionalsplit",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"moviesDBcsv": {},
									"before1960": {},
									"after1980": {},
									"allother": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"annotations": [],
				"lastPublishTime": "2022-12-28T05:14:31Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/moviesDBconditionalsplit')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/moviesDBderivedconDF')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "moviesDBderivedconDF",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "moviesDBderivedcoln",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"moviesdbcsv": {},
									"derivedcolnsink": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"annotations": [],
				"lastPublishTime": "2022-12-28T06:43:06Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/moviesDBderivedcoln')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/moviesDBexistes')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "moviesDBexists",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "moviesDBexists",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"moviesdbcsv": {},
									"moviesdbcopycsv": {},
									"moviesDBexistes": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"annotations": [],
				"lastPublishTime": "2022-12-28T08:35:03Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/moviesDBexists')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/moviesDBlookup')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "moviesDBlookup",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "moviesDBlookup",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"moviesdbcsv": {},
									"moviesdbcopycsv": {},
									"moviesDBexistes": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"annotations": [],
				"lastPublishTime": "2022-12-28T12:45:23Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/moviesDBlookup')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/moviesdB')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Data flow1",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "moviesdb",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"moviesdb": {},
									"sink1": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"annotations": [],
				"lastPublishTime": "2022-12-27T07:00:08Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/moviesdb')]"
			]
		}
	]
}